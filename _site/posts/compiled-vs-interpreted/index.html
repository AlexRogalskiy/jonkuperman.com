<!doctype html>
<html lang="en">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-21008844-11"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-21008844-11');
    </script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jon Kuperman</title>
    <meta name="Description" content="My personal website and blog.">
    <link rel="stylesheet" href="/css/index.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="Jon Kuperman">
    <link rel="shortcut icon" href="/img/favicon.ico" />
  </head>
  <body>
    <header>
      <h1 class="home"><a href="/">Jon Kuperman</a></h1>
      <ul class="nav"><li class="nav-item"><a href="/">Home</a></li><li class="nav-item"><a href="/posts/">Blog</a></li></ul>
    </header>

    <main class="tmpl-post">
      <div class="wrapper">
    <h1>Compiled vs. Interpreted Languages</h1>

    <figure>
    <img src="/img/code.png" alt="Code on a computer screen" />
    <figcaption>Photo by Joshua Aragon</figcaption>
</figure>
<p>I've been reading this <a href="http://craftinginterpreters.com/">fantastic book</a> called &quot;Crafting Interpreters&quot; lately by Bob Nystrom.</p>
<p>It talks about the different types of programming languages. We can think about all compilers as falling into three categories.</p>
<ol>
<li>Compilers that output machine code.</li>
<li>Compilers that output bytecode and need to be interpreted.</li>
<li>Compilers that output an intermediary format and then hand it off to another compiler.</li>
</ol>
<!-- excerpt -->
<p>There is a lot I find interesting about the book so far, but one thing that I was fascinated to read about the differences between &quot;compiled&quot; and &quot;interpreted&quot; languages.</p>
<p>Bob talks about if you are building a new language, you need to need to:</p>
<ol>
<li>Build a parser to handle your new syntax and build an AST.</li>
<li>Write any transformations or optimizations.</li>
<li>Build a generator to generate output code.</li>
</ol>
<p>This third step is the really interesting one!</p>
<p>An example of a compiler that does #3 from above (Compilers that output an intermediary format and then hand it off to another compiler) would be <a href="https://babeljs.io/">Babel</a>. Babel basically works like this.</p>
<ol>
<li>Let users author ES6+ JavaScript.</li>
<li>Turn it into an AST.</li>
<li>Transform the AST into the equivalent ES5 AST.</li>
<li>Convert the AST to JavaScript.</li>
<li>Hand that JavaScript off to a different compiler (the one in your browser).</li>
</ol>
<p>So, in this case, the &quot;output code&quot; that Babel generates is just JavaScript! But what if we wanted to make a language that actually generated CPU instructions?</p>
<h2 id="compiled-vs.-interpreted">Compiled vs. Interpreted <a class="direct-link" href="#compiled-vs.-interpreted">#</a></h2>
<h3 id="compiled">Compiled <a class="direct-link" href="#compiled">#</a></h3>
<p>If you are building a language that must run on multiple processor architectures (let's say x86 and ARM), you'll need to write two different &quot;back ends&quot; or &quot;generators.&quot; These will both take the same AST your compiler created and output CPU specific instructions (this is a lot of work!). These are what we refer to as &quot;compiled&quot; languages. Every compiled language has a custom generator for each CPU architecture they support.</p>
<h3 id="interpreted">Interpreted <a class="direct-link" href="#interpreted">#</a></h3>
<p>Another approach would be to build a single generator. Instead of having it generate code for an existing CPU architecture, you could have it generate code for a &quot;virtual&quot; or &quot;hypothetical&quot; CPU. This is what Java does and we refer to the output as &quot;bytecode.&quot;</p>
<p>If you create an interpreted language, you'll need to also build a &quot;virtual machine&quot; so that your hypothetical CPU code can run on real CPUs. This is where things are kind of neat but a little confusing.</p>
<p>If you build a VM (something capable of executing your generated bytecode) in an existing language, then the VM can run on any CPU architecture that compiles that language. So you can:</p>
<ol>
<li>Write in a custom langauge</li>
<li>Compile it to your custom bytecode</li>
<li>Make a small VM in a popular language like C</li>
<li>Now your custom language has only one generator and can run anywhere that C can compile!</li>
</ol>
<p>I thought this was an interesting distinction and made the different approaches C++ and Java took seem a lot more like a reasonable trade-off as opposed to a mystery.</p>


    <p><a href="/">‚Üê Home</a></p>
</div>

    </main>

    <footer>
      <div class="footer-follow">
        <a href="https://twitter.com/jkup?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @jkup</a>
        <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
      </div>
    </footer>

    <!-- Current page: /posts/compiled-vs-interpreted/ -->
  </body>
</html>
